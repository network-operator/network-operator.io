[{"uri":"http://network-operator.io/","title":"","tags":[],"description":"","content":"Network Operators for Kubernetes This project will be the home for using the Kubernetes Operator pattern for managing (primarily) on-premises network infrastructure and/or VMs.\nWhat is it? network-operator.io is a domain registered for creating Kubernetes Operators with a valid, owned domain.\nThe aim is to support multiple Operators for different things, such as:\n Meraki Deployments Streaming Telemetry Deployments Configuration of abstracted elements across multiple vendors, such as:  NTP Syslog ACLs    This operators would be generally opinionated while also allowing vendor-specific extensions/options.\nProposed Operators: Meraki An example of using a proposed Meraki Operator to define wireless networks might be the following:\n# manifests/network.yaml apiVersion: meraki.network-operator.io/v1alpha1 kind: Network metadata: name: network-sample spec: organization: example-org statusPage: local: enabled remote: enabled --- # manifests/rfprofile.yaml apiVersion: meraki.network-operator.io/v1alpha1 kind: RFProfile metadata: name: rfprofile-sample spec: network: network-sample band: selectionType: ap clientBalancing: yes steering: yes 5ghz: power: minimum: 8 maximum: 10 channel: width: 20 autoChannels: - 56 - 6 24ghz: power: minimum: 8 maximum: 10 channel: width: 20 autoChannels: - 1 - 6 - 11 --- # manifests/ssid.yaml apiVersion: meraki.network-operator.io/v1alpha1 kind: SSID metadata: name: example-ssid spec: network: network-sample ipAssignmentMode: nat vlans: tagging: yes default: 10 apAvailabilityTags: - site1 - prod bandSelection: steering auth: mode: psk psk: examplepsk123 encryption: wpa broadcast: yes lanIsolation: no --- # manifests/globalwirelesssettings.yaml apiVersion: meraki.network-operator.io/v1alpha1 kind: GlobalWirelessSettings metadata: name: globalwirelesssettings-sample spec: network: network-sample upgradeSetting: minimizeClientDowntime ledLights: on locationAnalytics: no mesh: no --- # manifests/ap1.yaml apiVersion: meraki.network-operator.io/v1alpha1 kind: AccessPoint metadata: name: accesspoint1-sample spec: network: network-sample serialNumber: abc123 physicalAddress: |123 Example St Somewhere, USA tags: - prod - site1 rfProfile: rfprofile-sample radios: 5ghz: channel: 60 power: 12 24ghz: channel: 6 power: 11 --- # manifests/ap2.yaml apiVersion: meraki.network-operator.io/v1alpha1 kind: AccessPoint metadata: name: accesspoint2-sample spec: network: network-sample serialNumber: 123abc physicalAddress: |123 Example St Somewhere, Canada tags: - prod - site1 rfProfile: rfprofile-sample The above could be easily templated with Helm and/or customized with Kustomize.\nProposed Operators: Abstracted The Abstracted Network Operator would allow you to define generic configurations that apply to all (or most) devices, such as NTP or Syslog. An example might be the following for configuring NTP on all devices:\n--- # manifests/device-a.yaml apiVersion: abstracted.network-operator.io/v1alpha1 kind: Device metadata: name: RouterA spec: serialNumber: xyz123 physicalAddress: |123 Example St Somerewhere, Canada os: name: nxos version: 7.0.3 tags: - prod - site3 --- # manifests/device-b.yaml apiVersion: abstracted.network-operator.io/v1alpha1 kind: Device metadata: name: RouterB spec: serialNumber: 123xyz physicalAddress: |123 Example St Somerewhere, UK os: name: eos tags: - prod - site2 --- # manifests/ntp.yaml apiVersion: abstracted.network-operator.io/v1alpha1 kind: NTP metadata: name: site-a spec: servers: - name: 0.pool.ntp.org preferred: yes - name: 1.pool.ntp.org vrf: management tags: - site3 The above Custom Resources would add two routers to device inventory, each with different tags. Then, it would create an NTP configuration, but only for devices in the inventory with the site3 tag (so, only RouterA in this example). Possibly extensions to his Custom Resource Definition might including being able to use external inventory sources, such as NetBox, with an additional parameter. An example of that might be:\n--- # manifests/netbox-inventory.yaml apiVersion: abstracted.network-operator.io/v1alpha1 kind: InventorySource metadata: name: netbox spec: server: netbox.example.com --- # manifests/ntp.yaml apiVersion: abstracted.network-operator.io/v1alpha1 kind: NTP metadata: name: site-a spec: inventory: netbox servers: - name: 0.pool.ntp.org preferred: yes - name: 1.pool.ntp.org tags: - site4 "},{"uri":"http://network-operator.io/blog/announcing-meraki-operator/","title":"Announcing the Meraki Operator","tags":[],"description":"","content":"Meraki Operator The Proof of Viability (PoV) for the Meraki Operator is nearly finished. The final step is to build and publish the image so that it can run within the cluster itself as it is currently only tested running external to the cluster. It has a limited feature set, but includes the following:\n Create a Meraki Network Create an RF Profile  Set valid channels for dynamic channel adjustments Set channel width for 5Ghz Set minimum and maximum transmit power for transmit power modifications Enable/disable client balancing   Create an SSID  Configure as Open or PSK authentication Set a PSK Set a networking mode  NAT Bridge Layer 3 Roaming   Set default VLAN ID   Adopt an MR Access Point  Set static 2.4Ghz and/or 5Ghz channels Set a static power target Set device tags   Configure global settings  Upgrade policy  Minimize client downtime Minimize upgrade time   Mesh networking Analytics collection   Support for multiple organizations and networks  As an example, the following manifests will:\n Create a network, RF Profile, and SSID Adopt an Access Point and select an RF Profile Define the upgrade strategy for APs to minimize client impact  --- apiVersion: meraki.network-operator.io/v1alpha1 kind: Network metadata: name: yyz-corporate spec: organization: Example Organization name: YYZ Corporate statusPage: local: enabled remote: disabled --- apiVersion: meraki.network-operator.io/v1alpha1 kind: RFProfile metadata: name: YYZ Default RF Profile spec: organization: Example Organization network: YYZ Corporate band: selectionType: ap steering: true clientBalancing: true fiveGhz: channel: width: 20 --- apiVersion: meraki.network-operator.io/v1alpha1 kind: SSID metadata: name: YYZ Corporate Employee SSID spec: organization: Example Organization network: YYZ Corporate authentication: mode: psk psk: ExamplePSK123 --- apiVersion: meraki.network-operator.io/v1alpha1 kind: AccessPoint metadata: name: ap1-yyz spec: organization: Example Organization network: YYZ Corporate physicalAddress: |123 Example St Columbia, SC USA radios: 24ghz: channel: 6 rfProfile: YYZ Default RF Profile serialNumber: ABCD-1234-WXYZ tags: - yyz - corp --- apiVersion: meraki.network-operator.io/v1alpha1 kind: GlobalWirelessSettings metadata: name: yyz-corporate-wifi-settings spec: upgradeSetting: minimizeClientDowntime On its own, this can be accomplished with Ansible (and, in fact, the PoV uses Ansible to do all of this!) or with a custom Python or Go project \u0026ndash; really, anything that leverages the Meraki API could do everything that the Meraki Operator does. However, the value comes from leveraging the Kubernetes ecosystem. The primary driver for this project was to:\n Provide an API frontend on which a company may already be standardized Provide an API frontent on which traditional developers could manage their networks Reduce the need to create custom frameworks, libraries, codebases, Ansible roles/playbooks, etc. Remove the need for managing authentication, authorization, auditing/logging, role-based access control, etc.  The above items are handled by leveraging native Kubernetes features and the Operator pattern. However, being able to leverage the wider Kubernetes ecosystem is another massive advantage.\nIntegrating OPA Gatekeeper Compliance is a huge advantage of the Kubernetes ecosystem. While some things are provided by Kubernetes itself (as mentioned above), some more complex requirements are not. For example, consider the following requirements for your wireless network:\n You must not use DFS channels The only SSID that can use \u0026ldquo;Open\u0026rdquo; authentication must be named Guest WiFi Your RADIUS servers must be from a list of servers  The first is an example of a local regulatory requirement; the second is an example of a mandate from your Security team; the third is an internal engineering standards requirement. All of these can be enforced via manual efforts and audits, peer review, etc. However, when leveraging the Meraki Operator with OPA Gatekeeper, these sorts of requirements can be enforced separate from your codebase, without requiring peer review, and with confidence that the state of your WiFi network is complying with regulatory, security, and architectural requirements! Additionally, areas where peer review might miss a violation (such as a typo in an IP address for a RADIUS server, such as writing 192.168.31.150 instead of 192.168.13.150) are now enforced by code for free! This provides benefits to the persona writing the change, the persona reviewing the change, and the person who initially defined the standard!\nTo show an example of this, we\u0026rsquo;ll examine the most simple of the above three examples: The only SSID that can use \u0026quot;Open\u0026quot; authentication must be named \u0026quot;Guest WiFi\u0026quot;. Normally, we would need peer review and audits to validate this. However, if we leverage OPA Gatekeeper to enforce this, we can be confident that our standards are enforced without requiring additional cognitive workload.\nFirst, install OPA Gatekeeper:\n$ kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/release-3.7/deploy/gatekeeper.yaml Once this is done, wait a few minutes for images to pull and pods to start. Next, create the ConstraintTemplate. This will create a parameterized Constraint Custom Resource Definition that we\u0026rsquo;ll use to define the name of the SSID that is valid.\napiVersion: templates.gatekeeper.sh/v1beta1 kind: ConstraintTemplate metadata: name: openssidrequirements spec: crd: spec: names: kind: OpenSSIDRequirements validation: # Schema for the `parameters` field openAPIV3Schema: properties: ssid_name: type: string targets: - target: admission.k8s.gatekeeper.sh rego: |package openssidrequirements violation[{\u0026#34;msg\u0026#34;: msg}] { provided := input.review.object.metadata.name required := input.parameters.ssid_name auth_mode := input.review.object.spec.authentication.mode auth_mode == \u0026#34;open\u0026#34; provided != required msg := sprintf(\u0026#34;the ssid name must be: %v\u0026#34;, [required]) } The above template checks to see if we\u0026rsquo;ve defined an SSID with an authentication mode of open. If it is, then it checks to see if the SSID name that was provided by the object matches the one defined by the Constraint. It\u0026rsquo;s important to note that a ConstraintTemplate doesn\u0026rsquo;t do anything on its own. To actually enforce our desired policy, we need to create the Constraint itself:\napiVersion: constraints.gatekeeper.sh/v1beta1 kind: OpenSSIDRequirements metadata: name: open-ssid-name-must-be-guest spec: match: kinds: - apiGroups: [\u0026#34;meraki.network-operator.io\u0026#34;] kinds: [\u0026#34;SSIDs\u0026#34;, \u0026#34;SSID\u0026#34;] parameters: ssid_name: \u0026#34;Guest WiFi\u0026#34; The above Constraint is of a type OpenSSIDRequirements, which matches the .spec.crd.spec.names.kindvalue from ourConstraintTemplateabove. It operates only on theSSIDsandSSIDobjects from themeraki.network-operator.ioAPI. Since these objects are where we create SSIDs and define authentication modes, these are the only objects we need to worry about. The.spec.parametersare passed to the associatedConstraintTemplate, so in this case, our Constraintsays that the SSID name must beGuest WiFiif the authentication mode isopen`. To simplify the steps above, our logic is now:\nif apiGroup == \u0026#34;meraki.network-operator.io\u0026#34; and kind in [\u0026#34;SSIDs\u0026#34;, \u0026#34;SSID\u0026#34;]: if object[\u0026#34;spec\u0026#34;][\u0026#34;authentication\u0026#34;][\u0026#34;mode\u0026#34;] == \u0026#34;open\u0026#34;: if object[\u0026#34;spec\u0026#34;][\u0026#34;name\u0026#34;] != \u0026#34;Guest WiFi\u0026#34;: raise ValueError(\u0026#34;When using Open authentication, the SSID name must be \u0026#39;Guest WiFi\u0026#39;\u0026#34;)  The above is written in Python, but is for illustrative purposes only. The code above does not exist anywhere.\n Now, if we try to create a new SSID, we\u0026rsquo;ll get an error. Given the following manifest:\napiVersion: meraki.network-operator.io/v1alpha1 kind: SSID metadata: name: invalid-wifi-name-open spec: organization: Example Organization network: YYZ Corporate name: Corporate WiFi authentication: mode: open When we try to apply it, we get an error with an appropriate message:\n$ kubectl apply -f invalid-wifi-name-open.yml Error from server ([open-ssid-name-must-be-guest] the ssid name must be: Guest WiFi): error when creating \u0026#34;fail.yaml\u0026#34;: admission webhook \u0026#34;validation.gatekeeper.sh\u0026#34; denied the request: [open-ssid-name-must-be-guest] the ssid name must be: Guest WiFi We can verify that the Constraint picked this up:\n$ kubectl describe openssidrequirements | sed -n \u0026#39;/Status/,$p\u0026#39; Status: Audit Timestamp: 2022-01-16T21:27:33Z By Pod: Constraint UID: 1746ddbe-7715-425c-8924-825c1607af2d Enforced: true Id: gatekeeper-audit-59d4b6fd4c-tw6sk Observed Generation: 3 Operations: audit status Constraint UID: 1746ddbe-7715-425c-8924-825c1607af2d Enforced: true Id: gatekeeper-controller-manager-66f474f785-g9r66 Observed Generation: 3 Operations: mutation-webhook webhook Constraint UID: 1746ddbe-7715-425c-8924-825c1607af2d Enforced: true Id: gatekeeper-controller-manager-66f474f785-ntkkh Observed Generation: 3 Operations: mutation-webhook webhook Constraint UID: 1746ddbe-7715-425c-8924-825c1607af2d Enforced: true Id: gatekeeper-controller-manager-66f474f785-qkxsv Observed Generation: 3 Operations: mutation-webhook webhook Total Violations: 1 Violations: Enforcement Action: deny Kind: SSID Message: the ssid name must be: Guest WiFi Name: invalid-wifi-name-open Namespace: default Events: \u0026lt;none\u0026gt;``` This enforces our standards using a decoupled approach. Different teams can own the policies, implementations, etc. We leverage technologies that are common to multiple teams, so our Security team can write a policy leveraging exactly the same toolset as they do for enforcing policies with developers deploying to Kubernetes, such as enforcing Read-Only Filesystems. This provides collaboration and low-friction cross-team interactions. It removes requirements to remember every tiny detail when implementing and reviewing: if something doesn\u0026rsquo;t conform to a standard, it will be rejected with a meaningful message, so you can simply write a change and adjust as necessary.\nHopefully this helps to show the advantage of managing a Meraki infrastructure (or any network configuration!) via the Kubernetes Operator pattern.\n"},{"uri":"http://network-operator.io/blog/","title":"Blogs","tags":[],"description":"","content":""},{"uri":"http://network-operator.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"http://network-operator.io/tags/","title":"Tags","tags":[],"description":"","content":""}]